import { Switch } from '@jupyterlab/ui-components';
import { NotebookActions } from '@jupyterlab/notebook';
import { ArrayExt } from '@lumino/algorithm';
import { ContentType } from './content';
import { FloatingWindow } from './floating';
import { MyIcons } from './icons';
/**
 * Class that implements the Code cell in StickyLand.
 */
export class StickyCode {
    constructor() {
        this.autoRun = false;
        this.autoRunScheduled = false;
        this.runScheduled = false;
        this.isDisposed = false;
        this.isFloating = false;
        this.floatingWindow = null;
        /**
         * We use a mutation observer to detect if the output area is redrawn.
         * Remember to disconnect the observer in the dispose() method.
         * @param mutationList Array of mutation records
         * @param observer The observer itself
         */
        this.codeOutputMutationHandler = (mutationList, observer) => {
            mutationList.forEach(d => {
                var _a, _b;
                // Remove the prompt area when the output node is updated
                if (d.addedNodes !== null) {
                    (_b = (_a = this.outputNode) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.jp-OutputPrompt')) === null || _b === void 0 ? void 0 : _b.forEach(d => d.remove());
                }
            });
        };
        /**
         * We use a mutation observer to detect if user focuses on the code cell in
         * StickyLand. Remember to disconnect the observer in the dispose() method.
         * @param mutationList Array of mutation records
         * @param observer The observer itself
         */
        this.codeClassMutationHandler = (mutationList, observer) => {
            mutationList.forEach(d => {
                var _a;
                if (d.attributeName === 'class') {
                    if ((_a = this.editorNode) === null || _a === void 0 ? void 0 : _a.classList.contains('jp-mod-focused')) {
                        this.executionCounter.classList.add('mod-focused');
                    }
                    else {
                        this.executionCounter.classList.remove('mod-focused');
                    }
                }
            });
        };
        /**
         * We listen to the execution state of this notebook. We use it to change the
         * execution counter to star if the cell is scheduled to run.
         * @param _ any
         * @param args Notebook and cell
         */
        this.handleExecutionScheduled = (_, args) => {
            // Change the execution counter
            if (args.cell.node === this.originalCell.node) {
                this.runScheduled = true;
                this.executionCount = null;
                this.executionCounter.innerText = '[*]';
            }
        };
        /**
         * We listen to the execution state of this notebook. We use it to change the
         * execution counter to star if the cell is scheduled to run.
         * @param _ any
         * @param args Notebook and cell
         */
        this.handleExecuted = (_, args) => {
            // Change the execution counter
            if (args.cell.node === this.originalCell.node) {
                this.runScheduled = false;
                if (this.executionCount === null) {
                    this.executionCounter.innerText = '[ ]';
                }
            }
        };
        /**
         * Helper function to handle code model state changes. The state change signal
         * is emitted with anything (input, output, etc.). This function follows the
         * signal pattern from lumino
         * (https://github.com/jupyterlab/extension-examples/tree/master/signals)
         * @param model CodeCellModel
         * @param args Arguments emitted from the model emitter, an example of the
         * signal structure is listed
         * [here](https://github.com/jupyterlab/jupyterlab/blob/5755ea86fef3fdbba10cd05b23703b9d60b53226/packages/cells/src/model.ts#L774)
         * The args is {name: str, oldValue: any, newValue: any}
         */
        this.handleStateChange = (model, args) => {
            const codeModel = model;
            switch (args.name) {
                case 'executionCount':
                    // Update the execution count
                    this.executionCount = codeModel.executionCount;
                    // JupyterLab redraws the output area when code is executed, so we need
                    // to hide the original output every time here
                    // https://github.com/jupyterlab/jupyterlab/blob/e4e323992d24f6c5e48d181381e23c547b665b15/packages/notebook/src/actions.tsx#L1156
                    if (this.originalCell.inputHidden) {
                        this.originalCell.outputHidden = true;
                    }
                    break;
                case 'isDirty':
                    // Color the execution based on the dirty state
                    if (args.newValue) {
                        this.executionCounter.classList.add('dirty');
                    }
                    else {
                        this.executionCounter.classList.remove('dirty');
                    }
                    break;
                default:
                    break;
            }
        };
        /**
         * Strip unnecessary elements from the nodes before appending it to stickyland
         */
        this.cleanCellClone = () => {
            var _a, _b, _c, _d, _e, _f, _g;
            // Remove the left region (prompt and collapser), header and footer
            (_a = this.cellNode.querySelector('.jp-Cell-inputCollapser')) === null || _a === void 0 ? void 0 : _a.remove();
            (_b = this.cellNode.querySelector('.jp-OutputCollapser')) === null || _b === void 0 ? void 0 : _b.remove();
            (_c = this.cellNode.querySelector('.jp-InputArea-prompt')) === null || _c === void 0 ? void 0 : _c.remove();
            (_d = this.cellNode
                .querySelectorAll('.jp-OutputPrompt')) === null || _d === void 0 ? void 0 : _d.forEach(d => d.remove());
            (_e = this.cellNode.querySelector('.jp-CellHeader')) === null || _e === void 0 ? void 0 : _e.remove();
            (_f = this.cellNode.querySelector('.jp-CellFooter')) === null || _f === void 0 ? void 0 : _f.remove();
            // Add class name to the rendered region
            (_g = this.cellNode
                .querySelector('.jp-OutputArea')) === null || _g === void 0 ? void 0 : _g.classList.add('sticky-code-output');
            this.cellNode.classList.add('sticky-code-cell');
            this.cellNode.classList.remove('hidden');
        };
        /**
         * Create a toolbar element
         * @param items List of toolbar item names and onclick handlers
         */
        this.createToolbar = (items) => {
            var _a, _b;
            const toolbar = document.createElement('div');
            toolbar.classList.add('sticky-toolbar', 'jp-Toolbar', 'sticky-code-toolbar');
            const buttonGroup = document.createElement('div');
            buttonGroup.classList.add('toolbar-buttons');
            const statusGroup = document.createElement('div');
            statusGroup.classList.add('toolbar-status');
            toolbar.appendChild(buttonGroup);
            toolbar.appendChild(statusGroup);
            // Add buttons into the toolbar
            items.forEach(d => {
                const item = document.createElement('div');
                item.classList.add('jp-ToolbarButton', 'jp-Toolbar-item');
                buttonGroup.appendChild(item);
                const itemElem = document.createElement('button');
                itemElem.classList.add('jp-ToolbarButtonComponent', 'button', 'jp-Button', 'toolbar-button', 'bp3-button', 'bp3-minimal', `button-${d.name}`);
                itemElem.setAttribute('title', d.title);
                itemElem.addEventListener('click', d.onClick);
                item.appendChild(itemElem);
                // Add icon to the button
                const iconSpan = document.createElement('span');
                iconSpan.classList.add('jp-ToolbarButtonComponent-icon');
                itemElem.appendChild(iconSpan);
                d.icon.element({
                    container: iconSpan
                });
            });
            // Hide the expand button at first
            (_b = (_a = buttonGroup
                .querySelector('.button-expand')) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.classList.add('no-display');
            // Add a toggle switch into the toolbar
            this.toggle = new Switch();
            this.toggle.valueChanged.connect((_, args) => {
                this.autoRun = args.newValue;
            });
            this.toggle.value = this.autoRun;
            this.toggle.label = 'auto-run';
            // Add a tooltip title
            this.toggle.node.setAttribute('title', 'Automatically run this cell after any other cell is executed');
            // Here we are not correctly attach the widget to a layout, so we need to
            // manually trigger the event binding
            const toggleSwitchNode = this.toggle.node.querySelector('.jp-switch');
            toggleSwitchNode === null || toggleSwitchNode === void 0 ? void 0 : toggleSwitchNode.addEventListener('click', this.toggle);
            buttonGroup.appendChild(this.toggle.node);
            // Add an execution counter into the toolbar
            this.executionCounter = document.createElement('div');
            this.executionCounter.classList.add('execution-counter');
            statusGroup.appendChild(this.executionCounter);
            return toolbar;
        };
        /**
         * Run the code cell. The implementation logic is: (1) change the original cell
         * as the active cell, (2) use the NotebookActions to run the current active
         * cell
         */
        this.execute = (restoreActiveCell = false) => {
            const restoreActiveCellIndex = this.notebook.content.activeCellIndex;
            // Find the cell index of the original cell
            // Note it can change as users can insert cells above and below the cell
            // Jupyter lab internally iterates through all widgets to find the index
            // https://github.com/jupyterlab/jupyterlab/blob/5755ea86fef3fdbba10cd05b23703b9d60b53226/packages/notebook/src/widget.ts#L1803
            const cellIndex = ArrayExt.findFirstIndex(this.notebook.content.widgets, widget => widget.node === this.originalCell.node);
            // Change the active cell to the original cell
            this.notebook.content.activeCellIndex = cellIndex;
            // Blur the focused editor
            this.cell.editor.blur();
            // Run the active cell
            const runPromise = NotebookActions.run(this.notebook.content, this.notebook.context.sessionContext);
            // Restore the active cell if needed
            if (restoreActiveCell) {
                this.notebook.content.activeCellIndex = restoreActiveCellIndex;
            }
            return runPromise;
        };
        /**
         * Float the current code cell.
         */
        this.float = () => {
            // Create the floating window and put content from stickyland to the floating
            // window
            this.floatingWindow = new FloatingWindow(ContentType.Code, this);
            // Finally, toggle the `isFloating` property
            this.isFloating = true;
        };
        this.runClicked = (event) => {
            event.preventDefault();
            event.stopPropagation();
            // Run the cell
            this.execute(true);
        };
        this.launchClicked = (event) => {
            event.preventDefault();
            event.stopPropagation();
            this.float();
        };
        this.closeClicked = () => {
            // Show the original cell
            this.originalCell.inputHidden = false;
            this.originalCell.outputHidden = false;
            // TEMP: replace the current content with the dropzone
            this.stickyContent.showDropzone();
            // Remove the code cell
            this.dispose();
        };
        this.collapseClicked = (event) => {
            var _a, _b, _c, _d;
            event.preventDefault();
            event.stopPropagation();
            // Hide the input region
            this.cell.inputHidden = true;
            // Swap the icon in the toolbar
            (_b = (_a = this.stickyContent.headerNode
                .querySelector('.button-collapse')) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.classList.add('no-display');
            (_d = (_c = this.stickyContent.headerNode
                .querySelector('.button-expand')) === null || _c === void 0 ? void 0 : _c.parentElement) === null || _d === void 0 ? void 0 : _d.classList.remove('no-display');
            // Show the input placeholder
            this.placeholder.classList.remove('no-display');
        };
        this.expandClicked = (event) => {
            var _a, _b, _c, _d;
            event.preventDefault();
            event.stopPropagation();
            // Hide the input region
            this.cell.inputHidden = false;
            // Swap the icon in the toolbar
            (_b = (_a = this.stickyContent.headerNode
                .querySelector('.button-collapse')) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.classList.remove('no-display');
            (_d = (_c = this.stickyContent.headerNode
                .querySelector('.button-expand')) === null || _c === void 0 ? void 0 : _c.parentElement) === null || _d === void 0 ? void 0 : _d.classList.add('no-display');
            // Hide the input placeholder
            this.placeholder.classList.add('no-display');
        };
        this.toolBarItems = [
            {
                name: 'run',
                title: 'Run the cell',
                icon: MyIcons.runIcon,
                onClick: this.runClicked
            },
            {
                name: 'collapse',
                title: 'Hide the input',
                icon: MyIcons.collapseIcon,
                onClick: this.collapseClicked
            },
            {
                name: 'expand',
                title: 'Show the input',
                icon: MyIcons.expandIcon,
                onClick: this.expandClicked
            },
            {
                name: 'launch',
                title: 'Make the cell float',
                icon: MyIcons.launchIcon,
                onClick: this.launchClicked
            }
        ];
        /**
         * Bind event handlers for sticky code cell.
         */
        this.bindEventHandlers = () => {
            // Bind keyboard shortcuts
            this.node.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    if (e.shiftKey || e.ctrlKey) {
                        // [Shift + enter] or [control + enter] runs the code cell
                        this.execute(true);
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            });
        };
    }
    /**
     * Factory function for StickyCode when creating if from an existing cell
     * through dragging
     * @param stickyContent The sticky content that contains this markdown cell
     * @param cell The existing markdown cell
     * @param notebook The current notebook
     * @returns A new StickyCode object
     */
    static createFromExistingCell(stickyContent, cell, notebook) {
        const cd = new StickyCode();
        cd.stickyContent = stickyContent;
        cd.notebook = notebook;
        // Clone the cell
        cd.originalCell = cell;
        cd.cell = cd.originalCell.clone();
        // Register the original execution counter node
        cd.originalExecutionCounter = cd.originalCell.node.querySelector('.jp-InputArea-prompt');
        // Attach the clone node to stickyland
        cd.node = document.createElement('div');
        cd.node.classList.add('sticky-code');
        // Need to add tabindex so it can receive keyboard events
        cd.node.setAttribute('tabindex', '0');
        cd.stickyContent.contentNode.appendChild(cd.node);
        // Need to append the node to DOM first so we can do the cleaning
        cd.cellNode = cd.cell.node;
        cd.cellNode.classList.add('hidden');
        cd.node.appendChild(cd.cellNode);
        // Add a toolbar
        cd.toolbar = cd.createToolbar(cd.toolBarItems);
        cd.stickyContent.headerNode.appendChild(cd.toolbar);
        // Bind the Codemirror
        const codeMirrorNode = cd.cell.node.querySelector('.CodeMirror');
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        cd.codemirror = codeMirrorNode.CodeMirror;
        // Wow, for some reason the clone somehow has a different codemirror config
        // from the original cell, need to reset it here
        // https://codemirror.net/doc/manual.html#setOption
        cd.codemirror.setOption('lineWrapping', false);
        cd.executionCount = cd.cell.model.executionCount;
        // Collapse the original cell (both input and output)
        cd.originalCell.inputHidden = true;
        cd.originalCell.outputHidden = true;
        cd.cell.model.stateChanged.connect(cd.handleStateChange, cd);
        NotebookActions.executionScheduled.connect(cd.handleExecutionScheduled, cd);
        NotebookActions.executed.connect(cd.handleExecuted, cd);
        // Bind events
        cd.bindEventHandlers();
        // Clean the unnecessary elements from the node clone
        cd.cleanCellClone();
        // Add a mutation observer so we can style the execution counter based on
        // the code focus
        cd.codeObserver = new MutationObserver(cd.codeClassMutationHandler);
        cd.editorNode = cd.cellNode.querySelector('.jp-CodeMirrorEditor');
        if (cd.editorNode) {
            cd.codeObserver.observe(cd.editorNode, { attributes: true });
        }
        // Add an output area observer because we need to remove the left prompt
        // area every time the output area is updated
        cd.outputObserver = new MutationObserver(cd.codeOutputMutationHandler);
        cd.outputNode = cd.cellNode.querySelector('.jp-OutputArea');
        if (cd.outputNode) {
            cd.outputObserver.observe(cd.outputNode, { childList: true });
        }
        // Add a hidden placeholder element before the input area. We show it when
        // users collapse the input
        cd.placeholder = document.createElement('div');
        cd.placeholder.classList.add('jp-Placeholder-content', 'no-display');
        cd.placeholder.addEventListener('click', cd.expandClicked);
        if (cd.cell.node.firstElementChild !== null) {
            cd.cell.node.insertBefore(cd.placeholder, cd.cell.node.firstChild);
        }
        const placeholderIcon = document.createElement('div');
        placeholderIcon.classList.add('jp-MoreHorizIcon', 'placeholder-icon');
        MyIcons.ellipsesIcon.element({ container: placeholderIcon });
        cd.placeholder.appendChild(placeholderIcon);
        return cd;
    }
    /**
     * Setter function for the executionCount. It also updates the count element
     */
    set executionCount(newCount) {
        this._executionCount = newCount;
        // Update the counter element
        if (newCount !== null) {
            this.executionCounter.innerText = `[${newCount}]`;
            this.runScheduled = false;
        }
        else {
            if (!this.runScheduled) {
                this.executionCounter.innerText = '[ ]';
            }
        }
    }
    /**
     * Getter function for the executionCount.
     */
    get executionCount() {
        return this._executionCount;
    }
    /**
     * Factory function for StickyCode when creating if from a new code cell.
     * This function would append a new markdown cell to the main notebook.
     * @param stickyContent The sticky content that contains this markdown cell
     * @param notebook The current notebook
     * @returns A new StickyCode object
     */
    static createFromNewCell(stickyContent, notebook) {
        // Append a new code cell to the main notebook
        NotebookActions.insertBelow(notebook.content);
        NotebookActions.changeCellType(notebook.content, 'code');
        const newCell = notebook.content.activeCell;
        // Activate the original active cell
        notebook.content.activeCellIndex = notebook.content.activeCellIndex - 1;
        // Construct StickyCode using the new cell as an existing cell
        return this.createFromExistingCell(stickyContent, newCell, notebook);
    }
    dispose() {
        // Disconnect signal handlers
        this.codeObserver.disconnect();
        this.toggle.dispose();
        // Disconnect notebook execution signal
        NotebookActions.executionScheduled.disconnect(this.handleExecutionScheduled, this);
        NotebookActions.executed.disconnect(this.handleExecuted, this);
        // Remove nodes
        this.node.remove();
        this.toolbar.remove();
        this.isDisposed = true;
    }
}
StickyCode.numCd = 0;
