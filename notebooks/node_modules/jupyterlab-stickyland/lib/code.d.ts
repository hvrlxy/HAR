import { IDisposable } from '@lumino/disposable';
import { LabIcon, Switch } from '@jupyterlab/ui-components';
import { NotebookPanel, Notebook } from '@jupyterlab/notebook';
import { IChangedArgs } from '@jupyterlab/coreutils';
import { CodeCell, Cell, ICellModel } from '@jupyterlab/cells';
import CodeMirror from 'codemirror';
import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
import { StickyContent } from './content';
import { FloatingWindow } from './floating';
/**
 * Class that implements the Code cell in StickyLand.
 */
export declare class StickyCode implements IDisposable {
    node: HTMLElement;
    toolbar: HTMLElement;
    cellNode: HTMLElement;
    editorNode: HTMLElement | null;
    outputNode: HTMLElement | null;
    originalExecutionCounter: HTMLElement | null;
    private _executionCount;
    executionCounter: HTMLElement;
    placeholder: HTMLElement;
    static numCd: number;
    stickyContent: StickyContent;
    originalCell: CodeCell;
    cell: CodeCell;
    toggle: Switch;
    renderer: IRenderMime.IRenderer;
    notebook: NotebookPanel;
    codemirror: CodeMirror.Editor;
    codeObserver: MutationObserver;
    outputObserver: MutationObserver;
    autoRun: boolean;
    autoRunScheduled: boolean;
    runScheduled: boolean;
    isDisposed: boolean;
    isFloating: boolean;
    floatingWindow: FloatingWindow | null;
    /**
     * Factory function for StickyCode when creating if from an existing cell
     * through dragging
     * @param stickyContent The sticky content that contains this markdown cell
     * @param cell The existing markdown cell
     * @param notebook The current notebook
     * @returns A new StickyCode object
     */
    static createFromExistingCell(stickyContent: StickyContent, cell: CodeCell, notebook: NotebookPanel): StickyCode;
    /**
     * We use a mutation observer to detect if the output area is redrawn.
     * Remember to disconnect the observer in the dispose() method.
     * @param mutationList Array of mutation records
     * @param observer The observer itself
     */
    codeOutputMutationHandler: (mutationList: MutationRecord[], observer: MutationObserver) => void;
    /**
     * We use a mutation observer to detect if user focuses on the code cell in
     * StickyLand. Remember to disconnect the observer in the dispose() method.
     * @param mutationList Array of mutation records
     * @param observer The observer itself
     */
    codeClassMutationHandler: (mutationList: MutationRecord[], observer: MutationObserver) => void;
    /**
     * We listen to the execution state of this notebook. We use it to change the
     * execution counter to star if the cell is scheduled to run.
     * @param _ any
     * @param args Notebook and cell
     */
    handleExecutionScheduled: (_: any, args: {
        notebook: Notebook;
        cell: Cell<ICellModel>;
    }) => void;
    /**
     * We listen to the execution state of this notebook. We use it to change the
     * execution counter to star if the cell is scheduled to run.
     * @param _ any
     * @param args Notebook and cell
     */
    handleExecuted: (_: any, args: {
        notebook: Notebook;
        cell: Cell<ICellModel>;
    }) => void;
    /**
     * Helper function to handle code model state changes. The state change signal
     * is emitted with anything (input, output, etc.). This function follows the
     * signal pattern from lumino
     * (https://github.com/jupyterlab/extension-examples/tree/master/signals)
     * @param model CodeCellModel
     * @param args Arguments emitted from the model emitter, an example of the
     * signal structure is listed
     * [here](https://github.com/jupyterlab/jupyterlab/blob/5755ea86fef3fdbba10cd05b23703b9d60b53226/packages/cells/src/model.ts#L774)
     * The args is {name: str, oldValue: any, newValue: any}
     */
    handleStateChange: (model: ICellModel, args: IChangedArgs<any, any, string>) => void;
    /**
     * Setter function for the executionCount. It also updates the count element
     */
    set executionCount(newCount: number | null);
    /**
     * Getter function for the executionCount.
     */
    get executionCount(): number | null;
    /**
     * Factory function for StickyCode when creating if from a new code cell.
     * This function would append a new markdown cell to the main notebook.
     * @param stickyContent The sticky content that contains this markdown cell
     * @param notebook The current notebook
     * @returns A new StickyCode object
     */
    static createFromNewCell(stickyContent: StickyContent, notebook: NotebookPanel): StickyCode;
    /**
     * Strip unnecessary elements from the nodes before appending it to stickyland
     */
    cleanCellClone: () => void;
    /**
     * Create a toolbar element
     * @param items List of toolbar item names and onclick handlers
     */
    createToolbar: (items: {
        name: string;
        title: string;
        icon: LabIcon;
        onClick: (e: Event) => any;
    }[]) => HTMLElement;
    /**
     * Run the code cell. The implementation logic is: (1) change the original cell
     * as the active cell, (2) use the NotebookActions to run the current active
     * cell
     */
    execute: (restoreActiveCell?: boolean) => Promise<boolean>;
    /**
     * Float the current code cell.
     */
    float: () => void;
    runClicked: (event: Event) => void;
    launchClicked: (event: Event) => void;
    closeClicked: () => void;
    collapseClicked: (event: Event) => void;
    expandClicked: (event: Event) => void;
    toolBarItems: {
        name: string;
        title: string;
        icon: LabIcon;
        onClick: (event: Event) => void;
    }[];
    /**
     * Bind event handlers for sticky code cell.
     */
    bindEventHandlers: () => void;
    dispose(): void;
}
