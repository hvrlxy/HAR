import { NotebookActions } from '@jupyterlab/notebook';
import { FloatingWindow } from './floating';
import { ContentType } from './content';
import { MyIcons } from './icons';
/**
 * Class that implements the Markdown cell in StickyLand.
 */
export class StickyMarkdown {
    constructor() {
        this.isDisposed = false;
        this.isFloating = false;
        /**
         * Strip unnecessary elements from the nodes before appending it to stickyland
         */
        this.cleanCellClone = () => {
            var _a, _b, _c, _d, _e;
            // Remove the left region (prompt and collapser), header and footer
            (_a = this.cellNode.querySelector('.jp-Cell-inputCollapser')) === null || _a === void 0 ? void 0 : _a.remove();
            (_b = this.cellNode.querySelector('.jp-InputArea-prompt')) === null || _b === void 0 ? void 0 : _b.remove();
            (_c = this.cellNode.querySelector('.jp-CellHeader')) === null || _c === void 0 ? void 0 : _c.remove();
            (_d = this.cellNode.querySelector('.jp-CellFooter')) === null || _d === void 0 ? void 0 : _d.remove();
            // Add class name to the rendered region
            (_e = this.cellNode
                .querySelector('.jp-MarkdownOutput')) === null || _e === void 0 ? void 0 : _e.classList.add('sticky-md-output');
            this.cellNode.classList.add('sticky-md-cell');
            this.cellNode.classList.remove('hidden');
            // Render the latex on the clone node
            this.renderLatex();
        };
        /**
         * Bind event handlers for sticky markdown cell.
         */
        this.bindEventHandlers = () => {
            // Double click the rendered view should trigger editor
            this.node.addEventListener('dblclick', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this.cell.rendered) {
                    this.enterEditor();
                }
            });
            // Click on the rendered view should focus the current element
            this.node.addEventListener('click', (e) => {
                if (this.cell.rendered) {
                    this.node.focus();
                }
            });
            // Bind keyboard short cuts
            this.node.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    if (e.shiftKey || e.ctrlKey) {
                        // [Shift + enter] or [control + enter] render the markdown cell
                        if (!this.cell.rendered) {
                            this.quitEditor();
                        }
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    else {
                        // [Enter] in rendered mode triggers the editor
                        if (this.cell.rendered) {
                            this.enterEditor();
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }
                }
            });
        };
        /**
         * Create a toolbar element
         * @param items List of toolbar item names and onclick handlers
         */
        this.createToolbar = (items) => {
            const toolbar = document.createElement('div');
            toolbar.classList.add('sticky-toolbar', 'jp-Toolbar');
            // Add buttons into the toolbar
            items.forEach(d => {
                const item = document.createElement('div');
                item.classList.add('jp-ToolbarButton', 'jp-Toolbar-item');
                toolbar.appendChild(item);
                const itemElem = document.createElement('button');
                itemElem.classList.add('jp-ToolbarButtonComponent', 'button', 'jp-Button', 'toolbar-button', 'bp3-button', 'bp3-minimal', `button-${d.name}`);
                itemElem.setAttribute('title', d.title);
                itemElem.addEventListener('click', d.onClick);
                item.appendChild(itemElem);
                // Add icon to the button
                const iconSpan = document.createElement('span');
                iconSpan.classList.add('jp-ToolbarButtonComponent-icon');
                itemElem.appendChild(iconSpan);
                d.icon.element({
                    container: iconSpan
                });
            });
            return toolbar;
        };
        /**
         * Helper function to enter the editor mode.
         */
        this.enterEditor = () => {
            // Trigger the editor
            this.cell.rendered = false;
            // Move the cursor on the first line before the first character
            this.cell.editor.focus();
            this.cell.editor.setCursorPosition({ line: 0, column: 0 });
        };
        /**
         * Helper function to quit the editor mode.
         */
        this.quitEditor = () => {
            // Trigger the rendered output
            this.cell.rendered = true;
            // Focus the cell node so we can listen to keyboard events
            this.node.focus();
            /**
             * Since we are not attaching the renderer widget to any other widget, the
             * onAttach method is never called, so the latex typesetter is never called
             * We need to manually call it after rendering the node
             */
            this.renderLatex();
        };
        /**
         * A helper function to force render latex after timeout.
         * @param timeout Call the latex renderer after `timeout` ms
         */
        this.renderLatex = (timeout = 100) => {
            /**
             * Since we are not attaching the renderer widget to any other widget, the
             * onAttach method is never called, so the latex typesetter is never called
             * We need to manually call it after rendering the node
             * https://github.com/jupyterlab/jupyterlab/blob/d48e0c04efb786561137fb20773fc15788507f0a/packages/rendermime/src/widgets.ts#L225
             */
            setTimeout(() => {
                var _a;
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                (_a = this.renderer.latexTypesetter) === null || _a === void 0 ? void 0 : _a.typeset(this.renderer.node);
            }, timeout);
        };
        /**
         * Float the current code cell.
         */
        this.float = () => {
            // Create the floating window and put content from stickyland to the floating
            // window
            this.floatingWindow = new FloatingWindow(ContentType.Markdown, this);
            // Finally, toggle the `isFloating` property
            this.isFloating = true;
        };
        this.editClicked = (event) => {
            event.preventDefault();
            event.stopPropagation();
            // Show the editing area
            if (this.cell.rendered) {
                this.enterEditor();
            }
        };
        this.runClicked = (event) => {
            event.preventDefault();
            event.stopPropagation();
            // Render the markdown
            if (!this.cell.rendered) {
                this.quitEditor();
            }
        };
        this.launchClicked = (event) => {
            event.preventDefault();
            event.stopPropagation();
            this.float();
        };
        this.closeClicked = () => {
            // Show the original cell
            this.originalCell.inputHidden = false;
            // TEMP: replace the current content with the dropzone
            this.stickyContent.showDropzone();
            // Remove the code cell
            this.dispose();
        };
        this.toolBarItems = [
            {
                name: 'run',
                title: 'Run the cell',
                icon: MyIcons.runIcon,
                onClick: this.runClicked
            },
            {
                name: 'edit',
                title: 'Edit the cell',
                icon: MyIcons.editIcon,
                onClick: this.editClicked
            },
            {
                name: 'launch',
                title: 'Make the cell float',
                icon: MyIcons.launchIcon,
                onClick: this.launchClicked
            }
        ];
    }
    /**
     * Factory function for StickyMarkdown when creating if from an existing cell
     * through dragging
     * @param stickyContent The sticky content that contains this markdown cell
     * @param cell The existing markdown cell
     * @param notebook The current notebook
     * @returns A new StickyMarkdown object
     */
    static createFromExistingCell(stickyContent, cell, notebook) {
        const md = new StickyMarkdown();
        md.stickyContent = stickyContent;
        md.notebook = notebook;
        // Clone the cell
        md.originalCell = cell;
        md.cell = md.originalCell.clone();
        // Collapse the original cell
        if (!md.originalCell.inputHidden) {
            md.originalCell.inputHidden = true;
        }
        // Save a reference to the cell's renderer (private)
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        md.renderer = md.cell._renderer;
        // Add a markdown cell element
        md.node = document.createElement('div');
        md.node.classList.add('sticky-md');
        // Need to add tabindex so it can receive keyboard events
        md.node.setAttribute('tabindex', '0');
        md.stickyContent.contentNode.appendChild(md.node);
        // Add a toolbar
        md.toolbar = md.createToolbar(md.toolBarItems);
        md.stickyContent.headerNode.appendChild(md.toolbar);
        // Clean the markdown cell
        // Need to append the node to DOM first so we can do the cleaning
        md.cellNode = md.cell.node;
        md.cellNode.classList.add('hidden');
        md.node.appendChild(md.cellNode);
        // Bind the Codemirror
        const codeMirrorNode = md.cell.node.querySelector('.CodeMirror');
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        md.codemirror = codeMirrorNode.CodeMirror;
        // Bind events
        md.bindEventHandlers();
        // Clean the unnecessary elements from the node clone
        md.cleanCellClone();
        return md;
    }
    /**
     * Factory function for StickyMarkdown when creating if from a new markdown
     * cell. This function would append a new markdown cell to the main notebook.
     * @param stickyContent The sticky content that contains this markdown cell
     * @param notebook The current notebook
     * @returns A new StickyMarkdown object
     */
    static createFromNewCell(stickyContent, notebook) {
        // Append a new markdown cell to the main notebook
        NotebookActions.insertBelow(notebook.content);
        NotebookActions.changeCellType(notebook.content, 'markdown');
        const newCell = notebook.content.activeCell;
        // Activate the original active cell
        notebook.content.activeCellIndex = notebook.content.activeCellIndex - 1;
        // Construct StickyMarkdown using the new cell as an existing cell
        return this.createFromExistingCell(stickyContent, newCell, notebook);
    }
    dispose() {
        this.node.remove();
        this.toolbar.remove();
        this.isDisposed = true;
    }
}
