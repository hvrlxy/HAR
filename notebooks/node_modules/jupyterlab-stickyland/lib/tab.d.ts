import { IDisposable } from '@lumino/disposable';
import { NotebookPanel, Notebook } from '@jupyterlab/notebook';
import { Cell, ICellModel } from '@jupyterlab/cells';
import { StickyContent } from './content';
import { StickyCode } from './code';
import { StickyLand } from './stickyland';
import { ContentType } from './content';
export declare type Tab = {
    cellType: ContentType;
    cellIndex: number;
    tabNode: HTMLElement;
    tabContent: StickyContent;
    hasNewUpdate: boolean;
};
export declare class StickyTab implements IDisposable {
    stickyContainer: HTMLElement;
    node: HTMLElement;
    stickyLand: StickyLand;
    notebook: NotebookPanel;
    addButton: HTMLElement;
    activeTab: Tab | null;
    tabs: Tab[];
    autoRunTimeout: number | null;
    autoRunningCellNodes: Set<HTMLElement>;
    autoRunCells: StickyCode[];
    autoRunTabs: Tab[];
    isDisposed: boolean;
    constructor(stickyContainer: HTMLElement, panel: NotebookPanel, stickyLand: StickyLand);
    /**
     * Handle the executionScheduled signal.
     */
    handleExecutionScheduled: (_: any, args: {
        notebook: Notebook;
        cell: Cell<ICellModel>;
    }) => void;
    /**
     * Handle the executed signal.
     */
    handleExecuted: (_: any, args: {
        notebook: Notebook;
        cell: Cell<ICellModel>;
    }) => void;
    /**
     * Create a tab containing a dropzone content. The tab name is always 'new'
     * for new tabs. Creating a different content (after interacting with the
     * dropzone will update the tab name).
     * @returns New tab
     */
    createTab: () => Tab;
    /**
     * Close the given tab
     * @param tab Tab to close
     */
    closeTab: (tab: Tab) => void;
    /**
     * Change the currently active tab to the new tab
     */
    switchActiveTab: (newTab: Tab) => void;
    /**
     * Update the tab name for the active tab. This function is called when user
     * creates a new code/md cell.
     */
    updateActiveTab: () => void;
    dispose: () => void;
}
